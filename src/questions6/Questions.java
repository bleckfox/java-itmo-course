package questions6;

public class Questions {
    public static void main(String[] args) {
        Building building = new Building(Building.Color.ORANGE, 15);
        building.open();

        // 1. Где будут доступны элементы перечисления Color, объявленного в классе Building?
        /*
            Перечисление объявлено внутри класса Building и является вложенным типом.
            Влолженные типы имеют ограниченную область видимости и доступа, и по умолчанию доступны
            только внутри класса, в котором они объявлены.

            Перечисление может быть использовано только внутри класса и его внутренних классах.

            Если нужно использовать перечисление за переделами родительского класса, нужно:
                либо объявить перечисление, как отдельных класс/тип
                либо переместить на верхний уровень в файле
         */

        // 2. Где будут доступны классы RoomsCreator, FindSecretRooms и Room, объявленные
        // в классе Building?
        /*
            RoomsCreator - это локальный класс, объявленный в конструкторе Building.
                Его область видимости ограничена только внутри этого конструктора.
                Это означает, что RoomsCreator будет доступен только внутри конструктора
                Building для инициализации массива rooms. Вне конструктора Building класс
                RoomsCreator не будет виден.

            FindSecretRooms - это внутренний класс, объявленный в классе Building.
                Он имеет доступ к членам и методам внешнего класса Building, включая rooms.
                FindSecretRooms будет доступен внутри класса Building, а также внутри других
                внутренних классов Building. Однако он не будет доступен извне класса Building.

            Room - это вложенный (статический) класс, объявленный внутри класса Building.
                Он также имеет доступ к статическим членам и методам внешнего класса Building,
                включая rooms. Из-за модификатора доступа private у Room, он будет
                виден только внутри класса Building.
         */

        // 3. Правильно ли выбраны модификаторы доступа классов RoomsCreator, FindSecretRooms и Room?
        /*
            Зависит от логики приложения. Данные классы являются вспомогательными для класса
            Building и позволяют реализовать внутреннюю функциональность.
         */

        // 4. Перечисления являются static вложенными или non-static внутренними классами?
        /*

            Перечисления в Java являются нестатическими вложенными классами (non-static nested classes),
            также известными как внутренние классы (inner classes). Они объявляются внутри классов
            или интерфейсов и связаны с внешним классом или интерфейсом.

            По умолчанию, каждый элемент перечисления является статическим и финальным (static final).
            Это означает, что они могут быть доступны независимо от создания экземпляра внешнего
            класса и их значения не могут быть изменены после объявления.
         */

        // 5. В каких из объявленных в Building классах можно обратиться к его экземпляру,
        // как это сделать?
        /*
            В классе Building можно обратиться к его экземпляру внутри всех его внутренних
            классов, включая классы RoomsCreator, FindSecretRooms и Room. Для доступа к
            экземпляру класса Building внутри внутренних классов можно использовать
            имя Building.this.

            Доступ к экземпляру Building из внутреннего класса возможен только при наличии
            экземпляра внешнего класса.
         */

        // 6. Метод close класса Room переопределяет или затеняет метод close класса Building?
        /*
            Метод close() в классе Room затеняет метод close() из интерфейса CloseableItem,
            который класс Building реализует.

            Метод close() в классе Room имеет ту же сигнатуру (void close()), что и метод из
            интерфейса CloseableItem, но он не переопределяет метод из класса Building.
            Вместо этого, он представляет собой отдельную реализацию метода close(),
            уникальную для класса Room.
         */

        // 7. C какими модификаторами доступа может быть объявлен класс RoomsCreator?
        /*
            Модификаторы доступа не могут быть применены непосредственно к локальным классам,
            таким как RoomsCreator, объявленным внутри методов. Локальные классы автоматически
            наследуют доступ от окружающего их блока кода, и их доступ определяется
            доступом к окружающему блоку кода.
         */

        // 8. В конструкторе класса RoomsCreator используется свойство MAX_ROOMS_COUNT.
        // Чему равно его значение: 50 или 20? И почему?
        /*
            Значение равно 20.

            Это свойство скрывает (затеняет) статическое свойство с тем же именем из класса Building.
         */

        // 9. Значения каких свойств класса Building можно изменить из классов RoomsCreator,
        // FindSecretRooms, Room?
        /*
            color, rooms, isClosed

            Для доступа к свойствам класса Building из классов RoomsCreator, FindSecretRooms и
            Room, требуется иметь ссылку на объект класса Building, например, через экземпляр
            класса или доступ к нему через внешние классы.
         */

        // 10. Можно ли из класса RoomsCreator изменить значение аргумента color, переданного
        // в конструктор Building? Почему?
        /*
            Нет, потому что свойство final.
            Класс RoomsCreator имеет доступ только к полям и методам внешнего класса
            Building, а не к его локальным переменным.
         */

        // 11. Может ли класс Building наследоваться от класса RoomsCreator, класса FindSecretRooms
        // или класса Room? Почему?
        /*
            Класс Building не может наследоваться от класса RoomsCreator, класса FindSecretRooms
            или класса Room, поскольку они являются внутренними классами, объявленными внутри
            класса Building.

            Наследование возможно только между классами на одном уровне иерархии, то есть классы
            могут наследоваться от других классов или реализовывать интерфейсы.
         */

        // 12. Могут ли классы RoomsCreator, FindSecretRooms, Room, Color наследоваться от
        // Building? Почему?
        /*
            Классы RoomsCreator, FindSecretRooms, Room и Color не могут наследоваться от класса
            Building, поскольку Building является родительским классом, а они являются внутренними
            или вложенными классами внутри Building. Внутренние или вложенные классы имеют доступ
            к членам и методам внешнего класса, но сами по себе они не могут наследовать другие классы.
         */

        // 13. Можно ли класс FindSecretRooms сделать static классом? Что для этого нужно сделать?
        /*
            Если сделать класс статичным, то потребуется и некоторые свойства класса Building сделать
            статичными, например, свойство rooms. Все зависит от логики приложения.

            Сделать класс статичным можно добавив static в объявлении класса.
         */


        // 1. В каких случаях имеет смысл создать именованный класс, реализующий
        // java.lang.Runnable интерфейс?
        /*
            1. Когда нужно описать задачу или действие, которое может быть выполнено в отдельном потоке.
                Runnable представляет собой функциональный интерфейс, предназначенный для выполнения
                кода в параллельном потоке. Создание именованного класса, реализующего Runnable,
                позволяет определить код для этой задачи и передать его в объект потока для выполнения.
            2. Когда нужно, чтобы класс мог быть передан в метод, ожидающий объект типа Runnable.
                Например, если есть метод, принимающий Runnable в качестве параметра и выполняющий
                его в новом потоке, создание именованного класса, реализующего Runnable,
                позволяет передать этот класс в качестве аргумента.
            3. Когда вам необходимо расширить функциональность другого класса, который реализует Runnable.
                Создание именованного класса, наследующего от существующего класса, позволяет
                добавить свою логику или переопределить методы, связанные с выполнением кода в
                отдельном потоке.

            Использование именованных классов, реализующих Runnable, предоставляет более явный способ
            определения кода, который будет выполняться в параллельном потоке, и позволяет более
            гибко управлять этим кодом.
         */


        // 2. В каких случаях имеет смысл создать анонимный класс, реализующий
        // java.lang.Runnable интерфейс?
        /*
            1. Когда нужно определить и реализовать Runnable интерфейс внутри метода или блока кода,
                и нет необходимости в создании отдельного именованного класса. Анонимные классы
                предоставляют компактный способ определения и реализации интерфейса без создания
                дополнительного класса.
            2. Когда нужно передать Runnable в метод или конструктор, ожидающий объект типа Runnable,
                и код run() метода достаточно короткий или простой для определения непосредственно
                в аргументе.
            3. Когда нужно переопределить или добавить логику только для одноразового использования
                и нет необходимости в повторном использовании кода. Анонимные классы предоставляют
                способ определения и реализации интерфейса на месте без создания отдельного класса
                для таких случаев.

            Использование анонимных классов позволяет встроить реализацию интерфейса
            Runnable или других интерфейсов непосредственно в коде, где это требуется, и
            облегчает организацию и управление кодом. Однако стоит отметить, что анонимные
            классы не могут быть повторно использованы и не имеют собственных имен и
            идентификаторов, что может сделать код менее читабельным в случае более сложной
            логики или большого объема кода.
         */


        // 3. В каких случаях имеет смысл создать анонимный класс, реализующий
        // java.lang.Runnable интерфейс через лямбда выражение?
        /*
            1. Когда реализация Runnable состоит из одного метода, например, run(), и код этого
                метода короткий и простой. Лямбда-выражения предоставляют компактный и удобочитаемый
                способ определения и передачи таких функций.
            2. Когда нужно передать Runnable в метод или конструктор, ожидающий объект типа Runnable,
                и код run() метода достаточно простой для определения непосредственно в аргументе метода
                или конструктора.
            3. Когда нужно передать Runnable в функцию или метод, ожидающий функциональный интерфейс,
                с одним абстрактным методом. Лямбда-выражения могут быть автоматически преобразованы
                в функциональные интерфейсы, что делает код более лаконичным и удобочитаемым.

            Использование лямбда-выражений позволяет компактно определить реализацию интерфейса
            Runnable или других функциональных интерфейсов в одну строку кода, без необходимости
            создавать анонимные классы или именованные классы. Лямбда-выражения упрощают код и
            повышают его читаемость, особенно в случае простых и коротких реализаций.
         */


        // 4. Чем локальные классы отличаются от анонимных? Что у них общего?
        /*
            Общие черты:
                1. Оба типа классов могут быть определены и использованы локально внутри методов,
                    блоков кода или конструкторов.
                2. И локальные классы, и анонимные классы могут реализовывать интерфейсы или
                    расширять другие классы.
                3. Оба типа классов имеют доступ к переменным внешнего контекста, включая
                    локальные переменные и параметры методов, если они являются объявленными
                    как final или эффективно финализированными.
                4. Локальные классы и анонимные классы позволяют улучшить модульность и
                    организацию кода, позволяя определить и реализовать классы внутри
                    контекста, где они нужны.

            Различия:
                1. Локальные классы имеют имена, в то время как анонимные классы не имеют
                    явных имен и создаются непосредственно в месте их использования.
                2. Локальные классы могут быть повторно использованы в пределах метода или
                    блока кода, где они определены, тогда как анонимные классы могут
                    использоваться только в месте их определения.
                3. Локальные классы могут иметь свои собственные конструкторы и дополнительные
                    методы, в то время как анонимные классы могут иметь только методы,
                    определенные в интерфейсе или классе, которые они реализуют или расширяют.
                4. Локальные классы могут быть статическими или нестатическими, тогда как
                    анонимные классы всегда нестатические.
                5. Синтаксис определения и использования локальных классов и анонимных
                    классов отличается. Локальные классы объявляются с явным именем и
                    создаются с помощью ключевого слова new, в то время как анонимные классы
                    объявляются без имени и создаются непосредственно в месте их использования.
         */


        // 5. Что такое effective final переменные?
        /*
            "Effective final" - это термин, используемый в контексте локальных переменных в Java.
            Он описывает переменные, которые, хотя и не объявлены с ключевым словом final,
            фактически ведут себя как неизменяемые (т.е., их значения не изменяются после присвоения).

            Переменная считается "effective final", если она не присваивается новым значениям после
            инициализации. Это означает, что значение переменной фактически неизменно в рамках
            локального контекста, где она используется в локальном классе или анонимном классе.
         */


        // 6. Чем отличаются static вложенные от non-static внутренних классов?
        /*
            Это два различных типа. Их отличия:

            Статические вложенные классы (static nested classes):
                1. Объявляются с использованием ключевого слова static внутри другого класса.
                2. Могут быть созданы и использованы независимо от внешнего класса.
                3. Не имеют доступа к нестатическим членам внешнего класса.
                4. Могут иметь статические члены, методы и конструкторы.
                5. Могут быть созданы с помощью следующего синтаксиса:
                    OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();

            Нестатические внутренние классы (non-static inner classes):
                1. Объявляются внутри другого класса без использования ключевого слова static.
                2. Не могут быть созданы независимо от внешнего класса.
                    Для создания экземпляра нестатического внутреннего класса необходимо
                    сначала создать экземпляр внешнего класса.
                3. Имеют доступ ко всем членам и методам внешнего класса, включая его
                    нестатические члены.
                4. Не могут содержать статические поля, методы или конструкторы.
                5. Могут быть созданы с помощью следующего синтаксиса:
                    OuterClass.InnerClass innerObject = outerObject.new InnerClass();

            Оба типа классов используются для связи классов и создания более сложной иерархии
            классов внутри других классов. Выбор между статическим вложенным классом и
            нестатическим внутренним классом зависит от требуемой логики и отношений между
            классами. Статические вложенные классы обычно используются для создания
            вспомогательных классов или классов, которые не нуждаются в доступе к
            нестатическим членам внешнего класса. Нестатические внутренние классы обычно
            используются для создания более тесной связи с внешним классом и доступа к
            его нестатическим членам.
         */

    }
}
