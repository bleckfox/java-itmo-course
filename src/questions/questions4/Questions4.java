package questions.questions4;

public class Questions4 {

    // 1. Сколько классов может быть объявлено в одном файле?
    /*
        В языке программирования Java можно объявить только один публичный класс в каждом
        файле и любое количество не публичных классов. Публичный класс должен иметь имя,
        совпадающее с именем файла, в котором он объявлен. Остальные классы в файле могут
        быть объявлены без модификатора доступа или с модификатором доступа по умолчанию
        (package-private).
     */

    // 2. Чем отличается обычный класс от абстрактного?
    /*
    Короткий ответ "своими словами":
        Для абстрактного класса невозможно создать экземпляр, он испольузется для установки базовых
        свойств и методов для других обычных классов. У него можно прописать абстрактные методы,
        сделав обязательным их реализацию в дочерних классах. Наследуется только от абстрактного класса.

    Длинный ответ из справочника:
        Обычный класс (также известный как конкретный класс) и абстрактный класс в Java
        имеют следующие отличия:

            1. Создание объектов: Обычный класс может быть непосредственно инстанциирован,
                то есть можно создавать его объекты с помощью оператора `new`.
                Абстрактный класс не может быть инстанциирован напрямую, то есть нельзя
                создать объект абстрактного класса. Он предназначен для использования в
                качестве базового класса для других классов.

            2. Абстрактность: Обычный класс может содержать как конкретные методы, так и
                абстрактные методы. Абстрактные методы - это методы, которые объявлены без
                тела и должны быть реализованы в подклассах. Абстрактный класс, с другой
                стороны, может содержать как конкретные методы, так и абстрактные методы,
                но сам он объявлен с ключевым словом `abstract` и может содержать
                нереализованные абстрактные методы.

            3. Наследование: Обычный класс может наследоваться от другого обычного класса
                или абстрактного класса с помощью ключевого слова `extends`. Абстрактный
                класс может наследоваться только от другого абстрактного класса с помощью
                ключевого слова `extends`.

            4. Обязательность реализации: Если класс наследуется от абстрактного класса,
                то он должен реализовать (переопределить) все абстрактные методы, объявленные
                в абстрактном классе. Обычный класс не обязан реализовывать абстрактные методы.

            Таким образом, абстрактные классы предоставляют базовую структуру и поведение
            для подклассов, требуя при этом реализации некоторых методов в подклассах.
            Обычные классы могут быть непосредственно инстанциированы и не обязаны
            содержать абстрактные методы.
     */

    // 3. Расскажите про особенности каждого модификатора доступа
    /*
        1. public: Классы, методы, переменные или конструкторы, объявленные с модификатором
        доступа `public`, доступны из любого места программы, включая другие классы,
        пакеты и модули. Такие элементы являются общедоступными и могут быть использованы
        другими частями программы без ограничений.

        2. private: Классы, методы, переменные или конструкторы, объявленные с модификатором
        доступа `private`, доступны только внутри того же класса, где они объявлены.
        Они не видимы для других классов, пакетов или модулей. Применение `private` и
        спользуется для скрытия внутренних деталей реализации и обеспечения инкапсуляции.

        3. protected: Классы, методы, переменные или конструкторы, объявленные с
        модификатором доступа `protected`, доступны внутри того же класса, внутри подклассов
        и внутри других классов в том же пакете. Они также доступны для классов из других
        пакетов, но только в случае, если эти классы являются подклассами данного класса.
        Модификатор `protected` обеспечивает доступность для наследников и других
        классов внутри пакета.

        4. default (package-private): Если ни один из модификаторов доступа не указан,
        то по умолчанию применяется модификатор доступа `default` или известный также
        как "package-private". Классы, методы, переменные или конструкторы с
        модификатором доступа `default` доступны только внутри того же пакета.
        Они не видимы для классов в других пакетах, даже если они являются
        частью того же проекта.

     */

    // 4. В чем особенность свойств, объявленных с модификатором final?
    /*
        Модификатор `final` применяется к переменным, методам и классам

        1. Переменные: При объявлении переменной с модификатором `final`
            она становится константой, то есть ее значение нельзя изменить
            после инициализации. Попытка присвоения нового значения такой
            переменной вызовет ошибку компиляции. Объявление переменной с
            модификатором `final` требует, чтобы она была проинициализирована
            либо непосредственно при объявлении, либо в конструкторе класса.

        2. Методы: При объявлении метода с модификатором `final` запрещается его
            переопределение в подклассах. То есть подклассы не могут изменить реализацию
            такого метода. Методы, объявленные с модификатором `final`, обычно используются,
            когда разработчик хочет зафиксировать логику метода и предотвратить его
            изменение в подклассах.

        3. Классы: При объявлении класса с модификатором `final` запрещается наследование
            от этого класса. То есть другие классы не могут быть подклассами такого
            класса. Объявление класса с модификатором `final` применяется, когда
            требуется зафиксировать реализацию класса и предотвратить создание
            подклассов, которые могут изменить его поведение.

        Основная цель использования модификатора `final` - это обеспечение неизменности
        значений переменных, методов или классов. Он может использоваться для
        обозначения констант, предотвращения переопределения методов или запрета
        наследования классов. Это помогает создавать более безопасный и надежный код
        и упрощает его понимание и поддержку.
     */

    // 5. Если при объявлении не задать значения свойствам, то чему они будут равны?
    /*
        Если при объявлении свойству не задано значение (не инициализировано), то
        оно будет автоматически инициализировано соответствующим значением по умолчанию
        в зависимости от типа данных:

        Для числовых типов данных (byte, short, int, long, float, double) значения
        по умолчанию равны 0 или 0.0.

        Для типа boolean значение по умолчанию равно false.

        Для типа char значение по умолчанию равно символу с кодом 0, что обозначает нулевой символ.

        Для ссылочных типов данных (классы и интерфейсы) значение по умолчанию равно null.

        Локальные переменные (переменные, объявленные внутри методов или блоков кода)
        не инициализируются автоматически и требуют явного присвоения значения перед
        использованием, иначе компилятор выдаст ошибку.
     */

    // 6. Можно ли объявить свойство через var?
    /*
        Нет, ключевое слово var не может использоваться для объявления свойств класса.
     */

    // 7. Что такое конструктор?
    /*
        Конструктор - это специальный метод класса, который вызывается
        при создании объекта этого класса с помощью оператора new.
        Конструкторы позволяют инициализировать поля объекта и выполнять другие
        необходимые операции, необходимые при создании объекта.

        Конструкторы имеют то же имя, что и класс, в котором они определены,
        и не имеют явного типа возвращаемого значения. Конструкторы могут принимать
        параметры (аргументы) или не принимать их вовсе.
     */

    // 8. В каких случаях необходимо объявлять конструктор без параметров?
    /*
        Если в классе не объявлен ни один конструктор, компилятор Java автоматически
        создаст конструктор по умолчанию без параметров, который инициализирует поля
        класса значениями по умолчанию или нулевыми значениями, если они не являются
        примитивными типами данных. Однако, если в классе уже объявлен конструктор
        с параметрами, компилятор не будет создавать конструктор по умолчанию автоматически.

        Конструктор обязателен в следующих случаях:

        1. Когда требуется инициализация полей:
            Если у класса есть поля, которые должны быть проинициализированы
            при создании объекта, необходим конструктор, чтобы принять и задать
            значения этих полей.

        2. Когда требуется выполнить другие операции при создании объекта:
            Конструкторы позволяют выполнять дополнительные операции,
            такие как проверка и валидация аргументов, установка начального
            состояния объекта, вызов других методов и т. д.

        3. Когда класс является подклассом и требуется явный вызов конструктора
           базового класса:
            Если класс является подклассом и базовый класс не имеет конструктора
            без параметров, то подкласс должен явно вызвать конструктор базового
            класса с помощью ключевого слова `super` в своем конструкторе.

        4. Когда требуется перегрузка конструкторов:
            Если класс должен иметь несколько вариантов конструкторов с разными
            параметрами, необходимо явно объявить их, чтобы разрешить создание
            объекта с разными наборами аргументов.

        В общем случае, если у класса есть поля, которые требуют инициализации,
        или если требуется выполнить другие действия при создании объекта,
        то создание конструктора обязательно.
     */

    // 9. Сколько конструкторов можно объявить в классе?
    /*
        В классе можно объявить любое количество конструкторов, в том числе и ноль.
        Количество конструкторов, которые можно объявить, зависит только от
        потребности и логики вашего класса.

        В классе может быть несколько конструкторов с разными параметрами или
        разными перегрузками. Каждый конструктор должен иметь уникальную сигнатуру,
        определяющую его параметры (типы и порядок), чтобы компилятор мог различить их
        и вызвать соответствующий конструктор в зависимости от переданных аргументов
        при создании объекта.
     */

    // 10. Как вызвать один конструктор в другом?
    /*
        В Java, чтобы вызвать один конструктор в другом, используется ключевое слово this.
        Ключевое слово this представляет текущий объект класса и может быть использовано
        для вызова других конструкторов класса.

        Чтобы вызвать конструктор с помощью this:
            Вызов конструктора должен быть первым оператором в теле другого конструктора.
            Вызов конструктора должен иметь формат this(...) и передавать аргументы,
            если они требуются.
     */

    // 11. Для чего конструктор может быть объявлен с приватным модификатором доступа?
    /*
        Когда конструктор объявлен с приватным модификатором доступа, это означает,
        что конструктор является приватным и не может быть вызван извне класса.
        Такой подход используется для реализации концепции ограниченного доступа к
        созданию объектов и может иметь следующие применения:
            Ограничение создания объектов: Путем объявления конструктора с приватным
            модификатором доступа вы можете предотвратить создание объектов класса из
            других классов. Это может быть полезно, если нужно, чтобы все объекты
            класса были созданы только внутри самого класса или через статические методы класса.

            Реализация синглтона: Синглтон — это класс, для которого может быть создан
                только один объект. Для реализации синглтона конструктор объявляется
                приватным, а класс предоставляет статический метод для получения
                экземпляра класса. Если объект еще не создан, метод создает новый объект;
                в противном случае он возвращает существующий объект.

            Реализация фабричных методов: Фабричный метод - это статический метод,
                который возвращает объект класса. Конструктор класса может быть приватным,
                а создание объектов класса осуществляется через фабричные методы.
                Это позволяет классу контролировать процесс создания объектов, применять
                дополнительную логику или возвращать различные подтипы объектов.

            В целом, использование приватного конструктора позволяет контролировать
            доступ к созданию объектов и предоставляет гибкость для реализации
            различных паттернов и концепций в объектно-ориентированном программировании.
     */

    // 12. Как называются методы, устанавливающие значения свойств объекта?
    /*
        Методы, которые устанавливают значения свойств (полей) объекта, обычно называются
        "сеттерами" или "методами установки". Эти методы позволяют изменить
        значения полей объекта, устанавливая новые значения на основе переданных аргументов.
     */

    // 13. Как называются методы, возвращающие значения свойств объекта?
    /*
        Методы, которые возвращают значения свойств (полей) объекта, обычно
        называются "геттерами" или "методами получения". Эти методы предоставляют
        доступ к значениям полей объекта, позволяя получить текущие значения.
     */

    // 14. Какие методы считаются перегруженными?
    /*
        Методы считаются перегруженными, если они имеют одинаковые имена,
        но различаются в сигнатуре. Сигнатура метода определяется его именем и списком
        параметров (их типы и порядок). При перегрузке методов, возвращаемый тип или
        модификатор доступа не учитываются.

        При вызове перегруженного метода, компилятор определяет, какой именно метод
        должен быть вызван, основываясь на аргументах, переданных при вызове.
     */

    // 15. Для чего метод может быть объявлен с приватным модификатором доступа?
    /*
        Когда метод объявлен с приватным модификатором доступа, это означает, что метод
        является приватным и доступен только внутри того же класса. Такой подход
        используется для реализации концепции сокрытия информации и может
        иметь следующие применения:

            Внутренняя логика класса: Приватные методы могут использоваться для
                реализации внутренней логики и деталей работы класса.
                Они не предназначены для использования извне класса и служат для
                обеспечения модульности и упрощения кода.

            Вспомогательные методы: Приватные методы могут быть вспомогательными
                методами, которые используются внутри публичных методов класса
                для выполнения определенных операций. Они помогают разделить
                сложные задачи на более мелкие подзадачи и улучшить читаемость
                и поддерживаемость кода.

            Защита данных: Приватные методы могут использоваться для обработки и
                проверки данных, связанных с объектом. Они позволяют контролировать
                доступ к данным и предотвращать некорректное использование или
                изменение данных извне класса.

            Инкапсуляция: Приватные методы помогают обеспечить инкапсуляцию
                данных класса, скрывая внутренние детали реализации от
                внешнего кода и предоставляя только необходимый интерфейс
                для работы с объектом.

        В целом, использование приватных методов позволяет контролировать доступ к
        внутренним деталям класса и обеспечивает более четкую и гибкую архитектуру программы.
     */

    // 16. Для чего используется return?
    /*
        Ключевое слово return в языке используется для завершения выполнения
        метода и возврата значения из метода обратно в вызывающий код.
        Оно имеет следующие основные использования:

            Возврат значения из метода: return используется для возврата значения
            из метода обратно в вызывающий код. Возвращаемое значение указывается
            после ключевого слова return.

            Прерывание выполнения метода: return также используется для
            преждевременного завершения выполнения метода. Если return встречается
            внутри метода, выполнение метода прекращается, и управление передается
            обратно вызывающему коду.

            Возврат void: Когда методу не требуется возвращать значение, используется
            ключевое слово void в объявлении метода. В этом случае return без значения
            используется для прерывания выполнения метода.
     */

    // 17. Можно ли использовать return в void методах?
    /*
        Да, ответ на вопрос 16. Используется для прерыавния выполнеиня метода.
     */

    // 18. Что такое this? Когда обращение через this необходимо?
    /*
        Ключевое слово this представляет текущий объект, т.е. объект, для
        которого вызывается метод или в котором используется свойство.
        Оно может использоваться в нескольких контекстах:

            Обращение к свойствам объекта: Ключевое слово this используется для
            обращения к свойствам текущего объекта. Это особенно полезно,
            когда имена параметров метода или локальных переменных
            конфликтуют с именами свойств объекта.

            Вызов конструктора: Ключевое слово this также используется для вызова
            другого конструктора в том же классе из текущего конструктора.
            Это позволяет избежать дублирования кода, когда несколько конструкторов
            делают схожие действия.

            Обращение через this необходимо, когда в коде есть неоднозначность или конфликт
            имен между параметрами метода/конструктора и свойствами объекта. Оно помогает
            явно указать, что мы обращаемся к свойству объекта, а не к параметру или
            локальной переменной. Кроме того, this используется для вызова других
            конструкторов класса при использовании конструкторов с перегрузкой.
     */

    // 19. Как в языке реализовано наследование?
    /*
        Наследование реализуется путем создания подклассов (или производных классов)
        на основе существующего суперкласса (или базового класса).
        Подкласс наследует все свойства и методы суперкласса, а также
        может добавлять свои собственные свойства и методы.

        Для того чтобы класс наследовал свойства и методы другого класса,
        в объявлении класса указывается ключевое слово extends и имя класса-суперкласса.

        При наследовании возможно переопределение методов суперкласса в подклассе с
        помощью ключевого слова @Override. Также возможно обращение к методам
        суперкласса из подкласса с помощью ключевого слова super.
     */

    // 20. Разрешено ли множественное наследование классов?
    /*
        В языке программирования Java не разрешено множественное наследование классов.
        Это означает, что класс может наследоваться только от одного класса (суперкласса).
        Это было сделано для упрощения языка и предотвращения некоторых проблем,
        связанных с множественным наследованием.

        Однако в Java существует возможность реализации множественного наследования
        через интерфейсы. Класс может реализовывать несколько интерфейсов, что позволяет
        ему наследовать сигнатуры методов из разных источников.
     */

    // 21. Какой тип данных является общим для всех классов в языке?
    /*
        Все классы наследуются от класса Object, поэтому тип данных Object
        является общим для всех классов. Класс Object является корневым классом
        в иерархии наследования и предоставляет базовый функционал, который
        доступен для всех объектов в Java.

        Класс Object определяет несколько методов, которые можно использовать в любом классе:
            toString(): Возвращает строковое представление объекта.
            equals(): Проверяет, равен ли данный объект другому объекту.
            hashCode(): Возвращает хеш-код объекта.
            getClass(): Возвращает объект класса Class, представляющий класс объекта.
            finalize(): Выполняет действия перед тем, как объект будет утилизирован сборщиком мусора.

        Поскольку все классы наследуются от Object, они автоматически имеют доступ к этим
        методам. При необходимости можно переопределить эти методы в пользовательских
        классах для более специфической реализации.
     */

    // 22. Как запретить наследование?
    /*
        Можно запретить наследование класса, используя ключевое слово final в объявлении класса.
        Когда класс объявлен как final, он становится "запечатанным" и не может быть расширен
        другими классами.
     */

    // 23. Что означает переопределение метода?
    /*
        Переопределение метода означает определение новой реализации (тела) метода в
        подклассе, который уже был объявлен в его суперклассе (базовом классе).
        При переопределении метода в подклассе, его реализация в суперклассе
        становится недоступной для объектов подкласса.

        Должны быть выполнены следующие условия:

            Метод в подклассе должен иметь ту же сигнатуру
            (имя, типы параметров и возвращаемое значение) как и в суперклассе.

            Модификатор доступа метода в подклассе должен быть таким же или
            менее ограничивающим, чем в суперклассе.

            Метод в суперклассе не должен быть объявлен как final, так как final
            методы нельзя переопределить. Также методы, объявленные с модификатором
            private, не могут быть переопределены, так как они не наследуются подклассом.

            Тип возвращаемого значения метода в подклассе должен быть совместимым или
            подтипом типа возвращаемого значения метода в суперклассе.

            Использование аннотации @Override.
     */

    // 24. Как запретить переопределение метода?
    /*
        Можно запретить переопределение метода, добавив ключевое слово final
        перед объявлением метода в суперклассе. Когда метод объявлен как final,
        он становится "запечатанным" и не может быть переопределен в подклассах.
     */

    // 25. Для чего используется аннотация @Override?
    /*
        Аннотация @Override используется для указания, что метод в подклассе
        переопределяет метод с такой же сигнатурой в его суперклассе.
        Аннотация @Override не является обязательной, но ее использование
        рекомендуется для явного обозначения переопределения метода.

        Преимущества использования аннотации @Override:
            Проверка на корректность переопределения: Если в суперклассе не существует
            метода с такой сигнатурой, при использовании аннотации @Override компилятор
            выдаст ошибку, что позволяет обнаружить возможные опечатки или ошибки в
            названии метода или его сигнатуре.

            Улучшение читаемости кода: Аннотация @Override явно указывает, что метод
            является переопределением, что делает код более понятным для разработчиков,
            особенно при работе с большими иерархиями классов.
     */

    // 26. Какие методы можно переопределить?
    /*
        В языке программирования Java можно переопределить неабстрактные методы, которые
        наследуются от суперкласса и имеют доступные для переопределения модификаторы
        доступа.

        Переопределение метода возможно в случае, если выполняются следующие условия:
            Метод в суперклассе не объявлен как final, так как final методы нельзя переопределить.
            Метод в суперклассе не объявлен как static, так как static методы не связаны
                с экземплярами класса и не наследуются подклассами.
            Метод в суперклассе не объявлен как private, так как private
                методы не наследуются подклассами и, следовательно, не могут быть переопределены.
            Метод в суперклассе не объявлен с модификатором доступа, который
                делает его менее доступным, чем модификатор доступа в подклассе.
                Например, если метод в суперклассе объявлен с модификатором доступа
                protected, то метод в подклассе должен быть объявлен как protected
                или public, но не private.
     */

    // 27. Как вызвать конструктор родительского класса в дочернем?
    /*
        Для вызова конструктора родительского класса в дочернем классе необходимо
        использовать ключевое слово super и передать необходимые аргументы конструктору
        родительского класса.
     */

    // 28. Как вызвать метод родительского класса в дочернем?
    /*
        Для вызова метода родительского класса в дочернем классе в языке Java
        используется ключевое слово super.
     */

    // 29. В чем особенность наследования от абстрактного класса?
    /*
        Особенность наследования от абстрактного класса в языке Java заключается в том, что подкласс должен реализовать (переопределить) все абстрактные методы родительского абстрактного класса или сам быть объявлен абстрактным классом.

        Ключевые особенности наследования от абстрактного класса:
            Обязательная реализация абстрактных методов: Абстрактный класс может
                содержать абстрактные методы, которые не имеют реализации в самом классе.
                Когда класс наследуется от абстрактного класса, он должен обязательно
                предоставить реализацию всех абстрактных методов либо сам стать абстрактным классом.

            Расширение функциональности: Наследование от абстрактного класса позволяет
                подклассу расширить функциональность родительского класса.
                Подкласс может добавлять новые методы и свойства, а также переопределять
                унаследованные методы.

            Создание иерархии классов: Абстрактные классы могут использоваться для
                создания иерархии классов, где более общие абстрактные классы определяют
                базовые свойства и методы, а их конкретные подклассы предоставляют
                специфическую реализацию.
     */

    // 30. Можно ли объявить абстрактный класс с модификатором final?
    /*
        Нет, нельзя объявить абстрактный класс с модификатором final.
        Модификатор final указывает, что класс или метод является "запечатанным" и не
        может быть наследован или переопределен соответственно.
        Абстрактный класс, с другой стороны, предоставляет базовую структуру
        для наследования и расширения функциональности. Если класс объявлен как final,
        это означает, что нельзя создать подклассы, и, следовательно, невозможно будет
        реализовать абстрактные методы или использовать его в качестве базового класса
        для других классов.
     */

    // 31. Как создать экземпляр класса?
    /*
        Экземпляр класса создается с помощью оператора new.
     */

    // 32. Как обратиться к свойству объекта?
    /*
        Для доступа к свойству объекта в языке Java используется оператор точки (.)
     */

    // 33. Как вызвать метод у объекта?
    /*
        Для доступа к свойству объекта в языке Java используется оператор точки (.)
     */

    // 34. В чём отличие static свойств и методов от не static свойств и методов?
    /*
        Отличие между статическими (static) свойствами и методами и нестатическими (non-static)
        свойствами и методами в языке Java заключается в их принадлежности и способе использования.

        Статические свойства:
            Принадлежат классу, а не конкретному экземпляру класса.
            Объявляются с использованием ключевого слова static.
            Существует только одна копия статического свойства для всего класса,
                независимо от количества созданных объектов.
            Можно обращаться к статическим свойствам напрямую через имя класса,
                без создания экземпляра класса.

        Нестатические свойства:
            Принадлежат конкретному экземпляру класса.
            Объявляются без использования ключевого слова static.
            Каждый объект класса имеет свою собственную копию нестатических свойств.
            Для доступа к нестатическим свойствам необходимо создать экземпляр
                класса и обращаться к свойствам через этот экземпляр.

        Статические методы:
            Принадлежат классу, а не конкретному экземпляру класса.
            Объявляются с использованием ключевого слова static.
            Можно вызывать статические методы напрямую через имя класса,
                без создания экземпляра класса.
            Не имеют доступа к нестатическим свойствам или методам класса,
                только к другим статическим свойствам и методам.

        Нестатические методы:
            Принадлежат конкретному экземпляру класса.
            Объявляются без использования ключевого слова static.
            Необходимо создать экземпляр класса для вызова нестатических методов.
            Имеют доступ ко всем свойствам и методам объекта, включая статические свойства и методы.
     */

    // 35. Для решения каких проблем чаще всего используются static методы?
    /*
        Статические методы в Java обычно используются для решения следующих проблем:

        1. Вспомогательные утилиты: Статические методы часто используются для
            создания вспомогательных утилитарных функций, которые выполняют общие
            операции и не требуют состояния объекта. Например, методы для работы с
            датами, математическими операциями, преобразованиями данных и т.д.

        2. Фабричные методы: Статические методы могут использоваться для создания
            объектов и возвращения экземпляров класса. Это позволяет скрыть детали
            создания объекта и предоставить удобный способ для получения экземпляров класса.
            Примером может служить метод `getInstance()` в шаблоне Singleton.

        3. Управление общими данными: Статические методы могут использоваться для управления
            общими данными, которые должны быть доступны внутри класса, но не являются
            уникальными для каждого экземпляра объекта. Например, счетчики, флаги состояния и т.д.

        4. Математические операции: Многие математические операции не требуют сохранения
            состояния объекта и могут быть реализованы как статические методы.
            Например, вычисление синуса, косинуса, логарифма и т.д.

        5. Валидация данных: Статические методы могут быть использованы для проверки и
            валидации данных, не требуя создания экземпляра объекта. Например, методы
            для проверки корректности вводимых значений или форматирования данных.

        Однако нужно помнить, что статические методы не имеют доступа к нестатическим
        свойствам и методам объекта, поэтому их следует использовать только для операций,
        не зависящих от конкретного состояния объекта.
     */

    // 36. Как обратиться к static свойству и вызвать static метод?
    /*
        Для обращения к статическому свойству и вызова статического метода
        используется имя класса, за которым следует оператор точки (.)
     */

    // 37. Сколько интерфейсов может быть объявлено в одном файле?
    /*
        Можно объявить несколько интерфейсов в одном файле. В отличие от классов,
        которые могут быть объявлены только по одному классу на файл, интерфейсы могут
        быть объявлены несколько в одном файле, при условии, что они имеют разные имена.
     */

    // 38. Что можно объявлять в интерфейсах?
    /*
        В интерфейсах можно объявлять следующие элементы:

            Абстрактные методы: Интерфейс может содержать объявления абстрактных методов,
                которые не имеют реализации. Абстрактные методы определяют сигнатуру метода
                (имя, параметры и тип возвращаемого значения), но не содержат его реализацию.
                Классы, реализующие интерфейс, должны предоставить конкретную реализацию
                для всех его абстрактных методов.

            Константы: Интерфейс может содержать объявления констант
                (переменных с ключевым словом final). Константы в интерфейсе являются
                неизменяемыми значениями и по умолчанию являются открытыми и статическими
                (public static final).

            Методы по умолчанию: В версии Java 8 и выше интерфейсы могут содержать
                методы с реализацией по умолчанию (default methods). Методы по умолчанию
                предоставляют реализацию по умолчанию для метода интерфейса, но могут
                быть переопределены в классах, реализующих интерфейс.

            Статические методы: В версии Java 8 и выше интерфейсы могут содержать статические
                методы. Статические методы интерфейса являются методами класса,
                и их можно вызывать напрямую через имя интерфейса, без создания экземпляра класса.
     */

    // 39. Сколько интерфейсов может реализовывать (имплементировать) класс?
    /*
        Класс может реализовывать (имплементировать) любое количество интерфейсов.
        Нет ограничений на количество интерфейсов, которые класс может реализовывать.

        Для реализации интерфейсов в классе используется ключевое слово implements,
        за которым следует список интерфейсов, разделенных запятыми.
     */

    // 40. Какие обязательства накладываются на класс, когда он реализует (имплементирует) интерфейс?
    /*
        Когда класс реализует (имплементирует) интерфейс в Java, ему накладываются следующие
        обязательства:

            1. Реализация всех абстрактных методов: Класс должен предоставить конкретную реализацию
                для всех абстрактных методов, объявленных в интерфейсе. Это означает,
                что класс должен определить тело каждого абстрактного метода, указанного в интерфейсе.

            2. Соблюдение сигнатур методов: Реализация методов в классе должна точно
                соответствовать сигнатурам методов, объявленных в интерфейсе.
                Это включает в себя имя метода, список параметров и тип возвращаемого значения.
                Если сигнатура метода в классе не соответствует сигнатуре метода в интерфейсе,
                компиляция класса вызовет ошибку.

            3. Публичная доступность методов: Реализация методов интерфейса в классе должна
                иметь модификатор доступа `public`. Интерфейс определяет контракт для
                внешнего мира, поэтому методы, реализующие интерфейс, должны быть доступными
                для использования извне класса.

            4. Правильное использование констант: Если интерфейс содержит константы,
                класс должен правильно использовать эти константы, обращаясь к ним через
                имя интерфейса (например, `InterfaceName.CONSTANT_NAME`).

        При реализации интерфейса класс может также добавлять свои собственные свойства и методы,
        которые не объявлены в интерфейсе. Однако класс должен предоставить реализацию всех
        методов, указанных в интерфейсе, и соблюдать контракт, определенный интерфейсом.
     */

    // 41. Когда разработчик обязан в классе переопределить default метод, объявленный в интерфейсе?
    /*
        Разработчик обязан переопределить default метод, объявленный в интерфейсе, в следующих случаях:

            Когда класс является абстрактным: Если класс, реализующий интерфейс, является
                абстрактным, то он не обязан предоставлять реализацию для всех методов
                интерфейса. Однако, если в интерфейсе есть default методы, то абстрактный
                класс должен переопределить их, предоставив конкретную реализацию.

            Когда default методы вызываются из других методов класса: Если в классе есть
            методы, которые вызывают default методы из интерфейса, то класс должен предоставить
            свою реализацию для этих методов. Иначе, компиляция класса вызовет ошибку,
            так как default методы могут иметь реализацию только в интерфейсе.

            В остальных случаях, если класс реализует интерфейс и в интерфейсе есть default
            методы, классу не требуется переопределять default методы, так как он уже
            предоставляет конкретную реализацию для всех абстрактных методов интерфейса.
     */

    // 42. Чем отличается интерфейс от абстрактного класса?
    /*
        Интерфейс и абстрактный класс в Java предоставляют различные механизмы для организации
        и структурирования кода, и имеют несколько ключевых отличий:

        1. Определение: Интерфейс представляет собой полностью абстрактную сущность,
            которая содержит только абстрактные методы (без реализации) и константы.
            Абстрактный класс является классом, который может содержать как абстрактные
            методы, так и конкретные методы (с реализацией), а также свойства.

        2. Реализация: Классы могут реализовывать (имплементировать) несколько интерфейсов,
            но могут наследоваться только от одного абстрактного класса. Интерфейс определяет
            контракт, который класс должен соблюдать, предоставляя реализацию для всех его методов.
            Абстрактный класс может предоставлять реализацию для некоторых методов и может
            содержать общую логику, которую наследники могут использовать.

        3. Множественное наследование: Класс может реализовывать несколько интерфейсов,
            что позволяет ему получить функциональность от различных источников.
            Абстрактный класс может наследоваться только от одного класса, что ограничивает
            возможность множественного наследования в Java.

        4. Использование свойств: Интерфейс не может содержать свойства (поля), только константы.
            Абстрактный класс может содержать свойства, которые наследники могут использовать.

        5. Гибкость: Использование интерфейсов обеспечивает большую гибкость, поскольку
            классы могут реализовывать несколько интерфейсов и предоставлять свою собственную
            реализацию для каждого из них. Абстрактный класс предлагает более сильную связь и
            часто используется для создания базовых классов или общей функциональности.

        В целом, выбор между интерфейсом и абстрактным классом зависит от конкретных
        требований проекта. Интерфейсы подходят для описания контрактов и определения
        общих методов, а абстрактные классы полезны, когда требуется предоставить
        базовую реализацию и общую функциональность для группы классов.
     */

    public static void main(String[] args) {
        
    }
}
